;####################################################
;###                                              ###
;##                STANDARD LIBRARY                ##
;#                                                  #
;#  Useful functions reused by other scripts        #
;#  Other ones may be found within libs/utils.ll    #
;#                                                  #
;##     (c) 2002-2022 MICHAUD Yannick              ##
;###                                              ###
;####################################################

(register 'ra needsUndef)
(register 'needsUndef nil)
(loadLibrary 'System)
(setq KsyNET "KsyNET")
(setq tab "\tab\")
(setq crlf "\cr\\lf\")
(setq lfcr "\nl\\cr\")
(setq cr "\cr\")
(setq lf "\lf\")
(setq vtab "\vtab\")
(setq backspace (char 8))
(defun cadar(l) (c_r 'cadar l))

(setq isLinux (cond ((== (getenv 'os.name) "Linux") t) (t nil)))
###### To emulate a simple ++var & var++ behaviour
# ++V
(undef ppV (v) (v.incr))
# V++
(defun Vpp (v) (let r v) (v.incr) r)
###### Two simple operators for threadObjects fields access
(addOp ':: 'getField)
(addOp ':< 'setField)
(undef aujourdhui ()
  (date "EEEE dd MMMM yyyy")
)
(undef freemem ()
  (print (/p (runtime.freeMemory) (^ 1024 2) 5) " Mo")
)
(undef timeFor (func?t)
  (let t1 (currentTimeInMillis))
  (eval func)
  (let t2 (currentTimeInMillis))
  (print "It took " (- t2 t1) "ms")
)
(undef rationalToDecimal (r?0 p?10)
  (let ret r)
  (if (== (type r) Number)
    (let r (r.getRational))
    (let ret
      (/p
        (r.getP)
        (r.getQ)
        p
      )
    )
  )
  ret
)
(undef rational (p?0 q?1)
  (cond ((p.isComplex)
          (/ p q)
        )
        ((q.isComplex)
          (inverse (/ q p))
        )
        (t
          (new Number (new Rational p q))
        )
  )
)
(undef rationalToDecimalPrec (r?0 p?10)
  (let ret r)
  (if (== (type r) Number)
    (let r (r.getRational))
    (let ret
      (/p
        (r.getP)
        (r.getQ)
        p
      )
    )
  )
  (setPrecision ret p)
)
(undef lsplit (s l)
   (let m (mod (length s) l))
   (if (<> m 0)
      (let s (+ (spaces (- l m)) s))
   )
   (let tmp (split s l))
   (let tmp (replaceNth 1 tmp (trim (car tmp))))
)
(undef isNumber (n)
  (contains (type n) "NilNumber")
)
(undef areNumbers (l)
  (let c 
    (cond
      ((== l nil) nil)
      (t (car l))
    )
  )
  (cond
    ((== l nil) t)
    ((atom l) nil)
    ((isNumber c) (areNumbers (cdr l)))
    (t nil)
  )
)

(undef rnd (n)
  (let r (int (* (random) n)))
)
(undef rndTo (n)
  (incr (rnd n))
)
(undef mid (los p n)
  (let l (length los))
  (let i (+ (- l p) 1))
  (first (last los i) n)
)
(undef old_where (c s)
   (if (atom s) (let s (split s 1)))
   (s.resetToFirst)
   (let rez 0)
   (let i 1)
   (while (and (s.hasMoreElements) (== rez 0))
      (if (== c (s.nextElement)) (let rez i))
      (let i (incr i))
   )
   rez
)
(undef rafter (s param)
  (reverse (before (reverse s) param))
)
(undef rbefore (s param)
  (reverse (after (reverse s) param))
)
(undef addAlias (lib func alias)
  (cond ((!= lib NilFunctions) (let l (NIL.getLibrary lib)))
        (t (let l lib))
  )
  (l.addAlias func alias)
)
(setUserHelp 'addAlias (+ "Usage: addAlias LIBRARY|DUMMY FUNC_NAME ALIAS" crlf tab "Adds an ALIAS to LIBRARY for FUNC_NAME, if an unknown library is specified (DUMMY), NilVM sore aliases are used."))
(setq NilFunctions (NIL.getMyFunctions))

(undef publicMethods (obj)
  (let mmm (methods obj))
  (let pub nil)
  (for (let i 1) (<= i (length mmm)) (i.incr)
    (let mnm (car (method obj (nth i mmm))))
    (if (contains mnm 'public)
      (let pub (append pub (list (nth i mmm))))
    )
  )
  pub
)
(undef showCalls ()
   (let tc NIL.tc)
   (tc.calls)
)

;## CONVENIENT DISPLAY FOR TRACING LOOPS
(undef nth_fr (i)
   (cond ((not (i.isNumber))
            "aucun-ieme"
         )
         (t
            (+ i "iÃ¨me" )
         )
   )
)
(undef nth_en (i)
   (let l (new Number (last i (cond ((> i 9) 2)(t 1)))))
   (let r (% l 10))
   (cond ((not (i.isNumber))
            "none"
         )
         (t
            (cond ((and (>= (length l) 2)(== r 0)(> i 10))
                     (+ i 'eth)
                  )
                  (t
                     (cond ((== r 1)
                              (+ i 'st)
                           )
                           ((== r 2)
                              (+ i 'nd)
                           )
                           ((== r 3)
                              (+ i 'rd)
                           )
                           (t
                              (+ i 'th)
                           )
                     )  
                  )
            )
         )
   )
)

#**********************
#     Simple Menus
#**********************
(setq menu0 (list "Oui" "Non"))
(undef fonc0_1 () (print "Choix Oui") t)
(undef fonc0_2 () (print "Choix non") nil)

(undef choix (l)
  (let ml (length l))
  (l.resetToFirst)
  (print 'CHOIX)
  (let i 0)
  (while (l.hasMoreElements)
    (print (i.incr) " : " (l.nextElement))
  )
  (while (or (< (read 'answ "? ") 1) (> answ (length l)))
    # READ done in condition
  )
  answ
)

(undef emenu (n einvite prefix fprefix)
  (let ok nil)
  (while (not ok)
    (print (eval einvite))
    (print "*****************")
    (let menun (eval (+ prefix n)))
    (let choix (choix menun))
    (let ok1 nil)
    (let ok1
      (eval (list (+ fprefix n "_" choix)))
    )
    (let ok (not ok1))
    (if (and (== n 0) ok1) (let ok t))
  )

  (cond  ((and (== n 0) (not ok1)) nil)
    (t ok1)
  )
)
(undef menu (n invite prefix)
  (let ok nil)
  (while (not ok)
    (print invite)
    (print "*****************")
    (let menun (eval (+ prefix n)))
    (let choix (choix menun))
    (let ok1
      (eval (list (+ "fonc" n "_" choix)))
    )
    (let ok (not ok1))
    (if (and (== n 0) ok1) (let ok t))
  )

  (cond  ((and (== n 0) (not ok1)) nil)
    (t ok1)
  )
)

(undef makeQuickLoad (name fileName) 
   (eval (list 'undef name))
   (eval (list "defun" name '() (list "load" (+ "'" fileName)) ))
   (setUserHelp name (+ "Usage: " name crlf tab "Loads " fileName "."))
   (print tab "`(" name ")` to reload " fileName) 
)
(setUserHelp 'makeQuickLoad (+ "Usage: makeQuickLoad FunctionName ScriptName" crlf tab "Shortcut for (load 'FunctionName)"))

(undef needsLibraries (libs)
   (if (atom libs) (let libs (list libs)))
   (libs.resetToFirst)
   (while (libs.hasMoreElements)
      (let lib (libs.nextElement))
      (if (not (NIL.libraryExists lib)) (loadLibrary lib))
   )
)
(undef searchFunc (s)
  (let s (upcase s))
  (let rez1 (streamFilter nilfunctions "((name) ((upcase name).matches (+ '.* s '.*)) )"))
  (setq rez2 nil)
  (mapcar (lambda (lib) (setq rez2 (+ rez2 (searchFuncL s lib)))) libraries)
  (let rez3 (streamFilter functions "((name) ((upcase name).matches (+ '.* s '.*)) )"))
  (let rez (+ rez1 rez2 rez3))
  (unset rez2)
  rez
)
(undef searchFuncL (s lib)
  (let s (upcase s))
  (let rez1 (streamFilter (eval (+s lib ".functions")) "((name) ((upcase name).matches (+ '.* s '.*)) )"))
  (let rez1 (streamMap rez1 "((v) (+s lib '. v))" t))
  rez1
)
(undef searchHelp (s)
  (let s (upcase s))
  (let rez1 (streamFilter nilfunctions "((name) (and ((upcase name).matches (+ '.* s '.*)) (> (help name) 0)))"))
  (let rez2 (streamFilter functions        "((name) (and ((upcase name).matches (+ '.* s '.*)) (> (help name) 0)))"))
  (+ rez1 rez2)
)
(undef isSquare (n)
  (== (^ (int (sqrt n)) 2) n)
)

(undef saveFunc (funcname fn?nil )
  ( let fsrc ( eval ( makelist ( +s "(func " funcname ")" ) ) ) )
  ( if ( == fsrc nil ) ( return "This function does not exist..." ) )
  ( if ( == ( car fsrc ) nil )
    ( let fsrc ( replaceNth 1 fsrc ( +s _openParent _closeParent ) ) ) 
  )
  ( if ( not fn ) ( let fn ( +s funcname '.ll ) ) )
  ( let fh ( file fn 'w ) )
  ( fprintline fh ( cons 'undef ( cons funcname fsrc ) ) )
  ( fclose fh )
  ( print funcname " saved in " fn )
)


##################
## ThreadObject ##
##################
(undef getTOByName (name?"")
  (let tos (threadObjects))
  (tos.resetToFirst)
  (let rez nil)
  (while (tos.hasMoreElements)
    (let to (tos.nextElement))
    (if (== ((cadr to).getName) name)
      (rez.insertTail (cadr to))
    )
  )
  rez
)
###################
##  ENABLES GUI  ##
###################
(undef GUI () (NIL.gui.NilGraphicInterface.main nil))
(register 'needsUndef ra)
(print "stdlib loaded.")
(makeQuickLoad "stdlib" scriptFile)
