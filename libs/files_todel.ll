;################################################
;###                                          ###
;##                   FILES                    ##
;#                                              # 
;#  Simple functions to manage files and        #
;#  directories                                 #  
;#                                              #
;##  (c) 1997-2017 MICHAUD Yannick & KsyNET    ##
;###                                          ###
;################################################
(needsLibraries '(LIB.IO))

(undef mkdir)
(defun mkdir (path)
  (let dir (new File path))
  (dir.mkdir)
)
(undef rmdir)
(defun rmdir (path)
  (let dir (new File path))
  (dir.delete)
)
(undef subdir)
(defun subdir (dir)
  (if (<> dir nil)
    (if (atom dir)
      (let dir (list dir))
    )
    (let clp (car dir))
    (subdir (cdr dir))
    (cond
      (
        (isDirectory clp)
          (subdir (directory clp))
      )
      (
        t 
          (print clp)
      )
    )

  )
)
(undef copyFiles)
(defun copyFiles (dir to)
  (if (<> dir nil)
    (if (atom dir)
      (let dir (list dir))
    )
    (copyFiles (cdr dir) to)
    (let clp (car dir))
    (let tto (after clp ":\\\\"))
    (cond
      (
        (isDirectory clp)
          (copyFiles (directory clp) (+ to tto))
      )
      (
        t 
          (copy clp to)
      )
    )

  )
)
(undef xcopy)
(defun xcopy (a b)
  (print "Copying content of " a " to " b " ...")
  (copyFiles (list a) b)
)
(undef getFileName)
(defun getFileName (f)
  (let name (last (split f "\\")))
  (if (contains name "/")
    (let name (last (split name "/")))
  )
  name
)
(undef copy)
(defun copy (f to)
  (let name (getFileName f))
  (if (!= name "Thumbs.db")
    (let ff (file f "R"))
    (let fc (freadContent ff))
    (if (!= fc nil)
      (mkdir to)
      (let nf (file (+ to "\\" name) "W"))
      (print (+ "Copying " name " to " to))
      (fprintContent nf fc)
      (fclose nf)
    )
    (fclose ff)
  )
)
(undef subdirext)
(defun subdirext (dir e2 to)
  (if (<> dir nil)
    (let clp (car dir))
    (cond
      (
        (isDirectory clp)
          (subdirext (directory clp) e2 (+ to "/" clp))
      )
      (
        t 
          (copyAndAddExtension clp e2 to)
      )
    )

  )
)
(undef subdir2file)
(defun subdir2file (dir file)
  (if (<> dir nil)

    (let clp (car dir))
    (cond
      (
        (isDirectory clp)
          (subdir2file (directory clp) file)
      )
      (
        t 
          (fprint file clp)
      )
    )

    (subdir2file (cdr dir) file)
  )
)
(undef tree)
(defun tree (dir)
  (if (== dir "") (let dir (getenv "user.dir")))
  (print "tree of " dir)
  (subdir (list dir))
)
(undef tree2file)
(defun tree2file (dir filename)
  (setq outfile (file filename "W"))
  (if (== dir "") (let dir (getenv "user.dir")))
  (fprint outfile (+ "tree of " dir))
  (subdir2file (list dir) outfile)
  (fclose outfile)
)
(undef addExtensions)
(defun addExtensions (dir e2 to)
  (print "changing and copying to " to)
  ( subdirext dir e2 to)
)
(undef copyAndAddExtension)
(defun copyAndAddExtension (f e2 to)
  (let name (getFileName f ))
  (print "changing " f " to " to "/" name)
  (let ff (file f "R"))
  (let fc (freadContent ff))
  (mkdir to)
  (let nf (file (+ to "/" (newExtension name e2)) "W"))
  (fprintContent nf fc)
  (fclose nf)
  (fclose fc)
)
(undef newExtension)
(defun newExtension (f e2)
  (let el (split f "."))
  (cond
    (
      (not 
        (contains f ".")
      )
      (+ f "." e2)
    )
    (t
      (+ (car el) "." e2)

    )
  )
)

(undef explore)
(defun explore (dir func params)
  (if (<> dir nil)
    (let clp (car dir))
    (explore (cdr dir) func params)
    (cond
      (
        (isDirectory clp)
          (print "Entering " (getFileName clp))
          (explore (directory clp) func params)
      )
      (
        t 
          (eval (cons func (cons (quote clp) params)))
      )
    )

  )
)

(undef fsize)
(defun fsize (name)
  (let f (new File name))
  (f.length)
)
(undef testFile)
(defun testFile (f ff)
  (let fname (getFileName f))
  (if (< (fsize f) 11000)
    (let fc (file f 'R))
    (catch exception ((fprintline ff f) (print "fichier " fname " endommagÃ©.") (catch exception (()) (fclose fc)))
      (freadContent fc)
      (fclose fc)
    )
  )
)
(undef testMP3)
(defun testMP3 (dir)
  (if (== dir nil)
    (let dir (getenv 'user.dir))
  )
  (setq path (list dir))
  (setq errorFile (file "errors.txt" 'W))
  (setq ef (list 'errorFile))
  (explore path 'testFile ef)
  (fclose errorFile)
)
(undef moveTo)
(defun moveTo (f dir p)
  (let name (getFileName f))
  (let nname (+ dir "\\" name))
  (let ok t)
  (if p
    (if (fexists f)
      (let ok nil)
      (print "impossible de deplacer le fichier : " f)
    )
  )
  (if ok
    (renameTo f nname)
  )
)
(undef moveErrFiles)
(defun moveErrFiles ()
  (let line "")
  (let ef (file "errors.txt" 'R))
  (while (<> line eof)
    (let line (freadline ef))
    (if (<> line eof)
      (moveTo line "\\ERREURS\\" t)
    )
  )
  (fclose ef)
)
(undef unMoveErrFiles)
(defun unMoveErrFiles ()
  (let line "")
  (let ef (file "errors.txt" 'R))
  (while (<> line eof)
    (let line (freadline ef))
    (print "restoring " line)
    (if (<> line eof)
      (let name (last (split line "\\")))
      (renameTo (+ "\\ERREURS\\" name) line)
    )
  )
  (fclose ef)
)

