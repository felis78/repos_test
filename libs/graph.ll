;################################################
;###                                          ###
;##        GRAPH CONSTRUCTOR                   ##
;#                                              #
;#  needs objects and stdlib (already included  #
;#  but who knows...)                           #
;#                                              #
;##    (c) 2022 MICHAUD Yannick & KsyNET       ##
;###                                          ###
;################################################

;## Quick load
(makeQuickLoad 'lg scriptFile)

;INITIALIZATIONS
(needsLibraries 'IO)
(require 'libs/java '$java_)
(require 'libs/stdlib '$stdlib_)
(require 'libs/objects '$nilplus_)

(setq $graph_loaded nil)
(if (not (existsVariable '$graph)) (setq $graph nil) (setq $graph_n 0))

;# MAIN CLASS
(if (existsClass 'Node) ($nilplus_delClass 'Node))
($nilplus_addClass 'Node)
(Node><name "")
(Node><previous nil)
(Node><next nil)
(Node><graph "$graph")
(Node><value nil)
;(Node<-getNext "getNextNodes")
;(Node<-getPrev "getPrevNodes")
;(Node<-getValue "getNodeValue")
(setq $graph nil)
(setq $graph_n 0)

;# MAIN FUNCTIONS
(undef resetGraph (class?Node prefix?Node graph_name?"$graph")
  (let graph_n (+s graph_name '_n))
  (let graph nil)
  (if (existsVariable graph_name)
    (let graph (eval graph_name))
  )
  (graph.resetToFirst)
  (while (graph.hasMoreElements)
    (NIL.removeProperty (graph.nextElement))
  )
  (setqv graph_name nil)
  (setqv graph_n 0)
  (addNode "Start" "" nil nil class prefix graph_name)
  (print "Graph " graph_name " and nodes deleted, root " (+ prefix 0) " created.")
)

(undef addNode (name?NoName value?0 prev?nil next?nil class?Node prefix?Node graph_name?"$graph")
  (let graph_n_name (+s graph_name '_n))
  (let graph_n (eval graph_n_name))
  (let graph (eval graph_name))
  (let node_name name)
  (if (== name 'NoName)
    (let node_name (+ prefix graph_n))
  )
  ($nilplus_instantiate class node_name node_name)
  (let rprev prev)
  (let rnext next)
  (if (<> prev nil)
    (let rprev (list prev))
  )
  (if (<> next nil)
    (let rnext (list next))
  )
  (putVMProp NIL node_name rprev 'previous)
  (putVMProp NIL node_name rnext 'next)
  (putVMProp NIL node_name value 'value)
  (rmprop node_name 'maxInstances)
  (if (not (rnext.isEmpty)) (putVMProp NIL next (unique (cons node_name next.previous)) 'previous))
  (if (not (rprev.isEmpty)) (putVMProp NIL prev (unique (cons node_name prev.next)) 'next))
  (setqv graph_n_name (graph_n.incr))
  (setqv graph_name (cons node_name graph))
  node_name
)
(undef linkNodes)
(defun linkNodes (prev next)
  (let n1 ($nilplus_getObject prev))
  (let n2 ($nilplus_getObject next))
  (cond ((or (== n1 nil) (== n2 nil))
        nil
      )
      ((== n1 n2)
        (print "No 'AUTO-loop' allowed (same node)")
        nil
      )
      (t
        (if (not (contains next.previous prev)) (putVMProp NIL next (quicksort (cons prev next.previous)) 'previous))
        (if (not (contains prev.next next)) (putVMProp NIL prev (quicksort (cons next prev.next)) 'next))
        (+ prev " -> " next)
      )
  )
)
(undef delRNodes)
(defun delRNodes (node)
  (let o (NIL.getProperty node))
  (let nn node.next)
  (nn.resetToFirst)
  (let np node.previous)
  (np.resetToFirst)
  (let flag t)
  ;del where next.previous == node
  (while (nn.hasMoreElements)
    (let next (nn.nextElement))
    (let l (remove node next.previous))
    (putVMProp NIL next l 'previous)
    (if (== (length next.previous) 0)
      (delRNodes next)
    )
  )
  ;del where previous.next == node
  (let flag t)
  (while (np.hasMoreElements)
    (let prev (np.nextElement))
    (let l (remove node prev.next))
    (putVMProp NIL prev l 'next)
    (if (== (length prev.next) 0)
      (delRNodes prev)
    )
  )
  ;MODIFIED 11/03/2018, was removeProperty before
  (delNode node)
  o
)
(undef getNode)
(defun getNode (name?"Node0")
  ($nilplus_getObject name)
)
(undef getNodeValue)
(defun getNodeValue (node?Node0)
  (eval (+ node ".value" ))
)
(undef getNextNodes)
(defun getNextNodes (node?Node0)
  (eval (+ node ".next" ))
)(undef getPrevNodes)
(defun getPrevNodes (node?Node0)
  (eval (+ node ".previous" ))
)
(undef delNode)
(defun delNode (node)
  (cond  ((== node "Node0")
          (print "You cannot delete Node0")
          nil
        )
        (t
          ($nilplus_delObject node)
        )
  )
)
;# setting help
(setUserHelp "resetGraph" (+ "Usage: resetGraph" crlf tab "Resets the graph and deletes all nodes, except root."))

;#########################################################
;## BASIC DICTIONNARY
;#########################################################

(undef scanWords)
(defun scanWords (lw?nil name?'Node0 s?"")
  (let n name.next)
  (let v name.value)
  (cond ((== v '*)
        (let lw (cons s lw))
        s
      )
      (t
        (n.resetToFirst)
        (while (n.hasMoreElements)
          (let node (n.nextElement))
          (let lw (scanWords lw node.name (+ s v)))  
        )
      )
  )
  lw
)
(undef addWord)
(defun addWord (w node?'Node0)
;(print "New word ? " w " at " node)
  (catch exception ((let c nil)) (let c (first w)))
  (if (== c nil) (let c '*))
;(print "treating " c " at " node)
  (let n node.next)
;  (print "next=" n)
;  (print "value=*" node.value "*")
  (cond ((== node.value "")
          (let flag true)
          (let on node)
;         (print "seeking on " n)
          (n.resetToFirst)
          (while (and flag (n.hasMoreElements))
            (let on (n.nextElement))
            (if (== c on.value) (let flag false))
          )
          (cond (flag
                  (let nn (addNode node c node))
;           (print "(*) not found, added " c " after " nn " , continue with " (after w c))
                  (if (!= c '*) (addWord (after w c) nn))
                )
            (t 
;              (print "found, continue")
               (addWord (after w c) on)
            )
        )
      )
      ((!= node.value '*)
;        (print "not the end of word")
        (let flag true)
        (let on node)
;        (print "seeking on " n)
        (n.resetToFirst)
        (while (and flag (n.hasMoreElements))
          (let on (n.nextElement))
          (if (== c on.value) (let flag false))
        )
        (cond (flag
              (let nn (addNode node c node))
;            (print "(**) not found, added " c " on " nn " ,continue with " (after w c))
              (if (!= c '*)(addWord (after w c) nn))
            )
            (t 
;            (print "found, continue")
              (addWord (after w c) on)
            )
        )
      )
      (t
        (if (!= c '*) (print "Error adding " w))
      )
  )
  (+ "Word " w " added.")
  
)
(undef searchWord)
(defun searchWord (w node?'Node0)
;(print "search " w " from " node)
  (catch exception ((let c nil)) (let c (first w)))
  (if (== c nil) (let c '*))
  (let n node.next)
  (cond ((!= node.value '*)
        (let flag true)
        (n.resetToFirst)
        (while (and flag (n.hasMoreElements))
          (let on (n.nextElement))
;(print "comparing " c " and " on.value)
          (if (== c on.value) (let flag false))
        )
        (cond (flag nil)
            (t 
              (searchWord (after w c) on)
            )
        )
      )
      (t
        (cond ((!= c '*) (print "Unknown error while searching"))
            (t (print "Word found"))
        )
      )
  )
)

(undef delWord)
(defun delWord (w node?'Node0)
  (let c (first w))
  (if (== c nil) (let c '*))
  (let n node.next)
  (cond ((!= node.value '*)
        (let flag true)
        (n.resetToFirst)
        (while (and flag (n.hasMoreElements))
          (let on (n.nextElement))
          (if (== c on.value) (let flag false))
        )
        (cond (flag nil)
            (t 
              (delWord (after w c) on)
            )
        )
      )
      (t
        (cond ((!= c '*) (print "Unknown error while deleting") nil)
            (t
;En supprimant le dernier (*) tous les precedents uniques seront aussi supprimés
              (delRNodes node)
              t
            )
        )
      )
  )
  
)

(undef createDicoFromFileList)
(defun createDicoFromFileList (fname)
  (cond ((not (fexists fname))
        (+ "The file " fname " does not exist.")
      )
      (t
        (print "Starting creating graph." crlf "************************")
        (if ((getNode 'Node0).isEmpty) (addNode 'Node0))
        (loadText fname)
        (content.resetToFirst)
        (while (content.hasMoreElements)
          (let w (content.nextElement))
          (print "adding word " w)
          (addWord w)
        )
        (+ "Dictionnary graph created from file " fname ".")
      )
  )
)
(undef createDicoFromFile)
(defun createDicoFromFile (fname max?50000)
  (cond ((not (fexists fname))
        (+ "The file " fname " does not exist.")
      )
      (t
        (print "Starting creating graph." crlf "************************")
        (if ((getNode 'Node0).isEmpty) (addNode))
        (let f (file fname 'R))
        (let line (freadline f))
        (let i 1)
        (while (and (<= i max) (or (!= max 0) (!= line eof)))
          (print "#" i tab (addWord line))
          (let i (incr i))
          (let line (freadline f))
        )
        (+ "Dictionnary graph created from file " fname ".")
      )
  )
)

(undef listWords)
(defun listWords ()
  (let words (scanWords nil))
  (print "Found words : ")
  words
)

(undef $tLoadDico)
(defun $tLoadDico (fileName)
  (let rez nil)
  (if (fexists fileName)
    (let rez (new NilVM NIL))
    (evalVM rez (list "loadContext" (+ "'" fileName)))
  )
  (print "dico loaded : " rez)
  rez
)
(undef tloadDico)
(defun tloadDico (fileName)
  (threadEval (list '$tLoadDico (+ "'" fileName)))
)
(undef loadDico)
(defun loadDico (dn)
  (cond ((fexists dn)
        (loadContext dn)
        t
      )
      (t nil)
  )
)
;# RELOADS THE CONTEXT AND THEN RELOADS THE UPDATED SCRIPTS AND SAVES AGAIN
(undef updateDico)
(defun updateDico (dn)
  (let rez nil)
  (if (fexists dn)
    (let answ " ")
    (while (not (contains "YN" (upcase answ)))
      (read 'answ "It will unset or reset all variables, do you wish to continue (Y/N) ? ")
    )
    (if (== (upcase answ) 'Y)
      (print "Loading dico " dn)
      (loadContext dn)
      (print "reLoading configuration and scripts")
      (load 'libs/config)
      (read 'dn "Please enter the filename :")
      (print "Saving dico to " dn)
      (saveContext dn)
      (let rez "updated")
    )
  )
  rez
)
;#########################################################
;## BASIC ANAGRAMS
;#########################################################
(undef $p_anagram)
(defun $p_anagram (letters node?'Node0)
  (let v node.value)
 ;  (print "letters : " letters)
  (let rez v)
  (cond ((and (letters.isEmpty) (== v '*))
        (print "plus de lettres et fin de mot => on retourne \" \"")
        " "
      )
      ((== v '*)
        (print "il reste des lettres, mais courant est une marque de fin, on retourne nil")
        nil
      )
      (t
 ;        (print "on cherche au hasard une suite pour \'" v "\'")
        (cond ((letters.isEmpty)
              (let c '*)
            )
            (t
              (let r (rndTo (length letters)))
              (let c (nth r letters))
            )
        )
;        (print "on cherche \'" c "\' dans les next")
        (let nn node.next)
        (nn.resetToFirst)
        (let flag false)
        (let flag2 false)
        (let tmp "")
        (let rez2 "")
        (while (and (not flag) (nn.hasMoreElements))
          (let next (nn.nextElement))
          (let nc next.value)
          (let flag false)
          (let flag2 false)
          (cond ((and (== nc c) (!= c '*))
                (let flag true)
                (print "on teste \'" c "\' next node=" next)
                (let tmp ($p_anagram (removeNth r letters) next))
                (let tmprez (car tmp))
                (print "returned " tmp)
                (cond  ((== (length tmprez) 0)
                        (print "retour à nil, on continue")
                        (let flag false)
                      )
                      (t
                        (let tmp2 v)
                        (print "retour non vide:" tmp2)
                        (let rez (+ tmp2 tmprez))
                        (print "resultat temporaire:" rez)
                        (let flag true)
                        (let flag2 true)
                      )
                )
              )
              ((if (and (== c nc) (== c '*)))
                (print "end mark found on node " next)
                (let flag2 true)
                (let flag true)
                (let rez (let rez2 v))
              )
              ((== nc '*)
                (let flag2 true)
                (let rez2 "NO_REZ2")
                (cond ((not (nn.hasMoreElements))
                      (print "end, found next \'" nc "\', " next)
                      (let flag false)
                      (let next1 next)
                      (let rez2 (+ v " "))
                    )
                    (t
                      (print "found end mark \'" nc "\', " next ", continue")
                      (let flag false)
                      (let next1 next)
                      (let rez2 (+ v " "))
                    )
                )
              )
           )
        )
        (if (!= (length rez2) 0)
          (let rez rez2)
          (let flag2 true)
        )
        (cond ((and (not flag) (not flag2))
              (print "No next found")
              (let rez nil)
            )
            ((not flag2) (let rez c))
        )
      )
  )
  (let rez (list rez letters))
;  (print "return " rez)
  rez
)
(undef anagram)
(defun anagram (word)
  (cond ((== word "")
        (print "Empty word...")
      )
      (t
        ($p_anagram (bbsort (split word 1)))
      )
  )
)
(resetGraph)
;# END
(print "Graph loaded.")
(undef testDico)
(defun testDico (n?10)
  (createDicoFromFileLines 'textes/dico_temp.txt n)
)
;# TEST

#(undef TD)
(defun TD (n?1000)
  (createDicoFromFile 'textes/dico_temp.txt n)
)
